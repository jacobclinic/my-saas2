---
alwaysApply: true
---
# Comma Education - Next.js Architecture Standards

This project follows a layered architecture pattern with clear separation of concerns. All code should adhere to these standards.


## Architecture Layers

### 1. Server Actions (Orchestration Layer)
- **Location**: `src/lib/{module}/server-actions-v2.ts`
- **Responsibility**: Workflow orchestration, validation, and side effects
- **Pattern**: Use `withSession` wrapper, handle CSRF, revalidate paths

```typescript
export const actionName = withSession(
  async (params: ActionParams): Promise<ActionResponse> => {
    const client = getSupabaseServerActionClient();
    const logger = getLogger();
    const service = new ModuleService(client, logger);
    
    try {
      await verifyCsrfToken(params.csrfToken);
      
      const result = await service.operation(params.data);
      if (!result.success) {
        return actionFailure(result.error.message, ErrorCodes.SERVICE_LEVEL_ERROR);
      }
      
      revalidatePath('/path');
      return actionSuccess();
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      return actionFailure(errorMessage, ErrorCodes.INTERNAL_SERVER_ERROR);
    }
  }
);
```

### 2. Services (Business Logic Layer)
- **Location**: `src/lib/{module}/services/*.service.ts`
- **Responsibility**: Business logic, validation, and domain operations
- **Pattern**: Use Result pattern, proper logging, error handling

```typescript
export class ModuleService {
  constructor(
    private client: SupabaseClient<Database>,
    private logger: Logger
  ) {}

  async operationName(params): Promise<Result<T>> {
    try {
      const result = await databaseOperation(this.client, params);
      
      if (!result.success) {
        this.logger.error('Business logic error', { error: result.error });
        return failure(new ServiceError(result.error.message));
      }
      
      return success(result.data);
    } catch (error) {
      this.logger.error('Service error', { error });
      return failure(new ServiceError('Service error message'));
    }
  }
}
```

### 3. Database Operations (Data Access Layer)
- **Location**: `src/lib/{module}/database/mutations-v2.ts`, `queries.ts`
- **Responsibility**: Single database operations with proper error handling
- **Pattern**: Use Result pattern, comprehensive logging, type safety

```typescript
export async function operationName(
  client: Client, 
  params: OperationParams
): Promise<Result<T, DatabaseError>> {
  try {
    const { data, error } = await client
      .from(TABLE_NAME)
      .select() // or .insert(), .update(), .delete()
      .eq('id', id)
      .throwOnError()
      .single();

    if (error) {
      logger.error('Specific error message', error);
      return failure(new DatabaseError('User-friendly error message'));
    }

    return success(data);
  } catch (error) {
    logger.error('Something went wrong while [action]', {
      error: error instanceof Error ? error.message : String(error),
      stack: error instanceof Error ? error.stack : undefined,
      name: error instanceof Error ? error.name : undefined,
      // Add relevant context
    });
    return failure(new DatabaseError('Something went wrong while [action]'));
  }
}
```

## Type Safety Standards

### Database Types
- Always import: `import type { Database } from '~/database.types'`
- Use: `type Client = SupabaseClient<Database>`
- Use database types: `Database['public']['Tables']['table_name']['Insert']`

### Type Definitions
- **Location**: `src/lib/{module}/types/*.ts`
- Use PascalCase for types: `CreateClassParams`, `UpdateClassData`
- Extend database types when needed

## Error Handling Standards

### Result Pattern
- Use `Result<T, E>` for all operations
- Use `success(data)` and `failure(error)` helpers
- Use `ErrorCodes` enum for categorization

### Logging Standards
```typescript
logger.error('Error message', {
  error: error instanceof Error ? error.message : String(error),
  stack: error instanceof Error ? error.stack : undefined,
  name: error instanceof Error ? error.name : undefined,
  // Add relevant context
});
```

## File Organization

### Module Structure
```
src/lib/{module}/
├── server-actions-v2.ts    # Orchestration layer
├── services/               # Business logic
│   └── module.service.ts
├── database/              # Data access
│   ├── mutations-v2.ts
│   └── queries.ts
├── types/                 # Type definitions
│   └── module-v2.ts
├── hooks/                 # React hooks (if needed)
└── constants/             # Module constants
```

## Naming Conventions

### Functions and Methods
- Database functions: `camelCase` (createClass, updateClass, getClassById)
- Services: `PascalCase` + Service suffix (ClassService, SessionService)
- Actions: `camelCase` + Action suffix (createClassAction, updateClassAction)

### Files
- Use `kebab-case`: `server-actions-v2.ts`, `mutations-v2.ts`
- Use descriptive names: `class.service.ts`, `invoice.types.ts`

## Import Organization

### Standard Import Order
```typescript
// External libraries
import { SupabaseClient } from '@supabase/supabase-js';
import { revalidatePath } from 'next/cache';

// Internal core utilities
import { withSession } from '~/core/generic/actions-utils';
import getSupabaseServerActionClient from '~/core/supabase/action-client';
import getLogger from '~/core/logger';

// Database operations
import { createClass, updateClass } from './database/mutations-v2';
import { getClassById } from './database/queries';

// Services
import { ClassService } from './services/class.service';

// Types
import type { CreateClassParams, CreateClassResponse } from './types/class-v2';

// Constants
import { ErrorCodes } from '~/lib/shared/error-codes';
```

## Testing Standards

### Test Structure
```
tests/
├── database/     # Test database operations
├── services/     # Test business logic
├── actions/      # Test server actions
└── integration/  # Test complete workflows
```

### Test Patterns
- Test each layer independently
- Mock dependencies appropriately
- Use Result pattern in tests
- Test both success and failure scenarios

## Documentation Standards

### Code Comments
- Add JSDoc for public functions
- Document complex business logic
- Use TODO comments for future improvements
- Explain "why" not "what"

### Examples
```typescript
/**
 * Creates a new class with associated sessions and invoices
 * @param data - Class creation data
 * @returns Result with created class or error
 */
async createClass(data: CreateClassData): Promise<Result<Class>> {
  // Implementation
}
```

## Common Patterns

### Database Operation Pattern
```typescript
export async function createEntity(
  client: Client, 
  data: InsertEntityData
): Promise<Result<Entity, DatabaseError>> {
  try {
    const { data: entity, error } = await client
      .from(ENTITY_TABLE)
      .insert(data)
      .select()
      .throwOnError()
      .single();

    if (error) {
      logger.error('Failed to create entity', error);
      return failure(new DatabaseError('Failed to create entity'));
    }

    return success(entity);
  } catch (error) {
    logger.error('Something went wrong while creating entity', {
      error: error instanceof Error ? error.message : String(error),
      stack: error instanceof Error ? error.stack : undefined,
      name: error instanceof Error ? error.name : undefined,
    });
    return failure(new DatabaseError('Something went wrong while creating entity'));
  }
}
```

### Service Method Pattern
```typescript
async createEntity(data: CreateEntityData): Promise<Result<Entity>> {
  try {
    const result = await createEntity(this.client, data);
    
    if (!result.success) {
      this.logger.error('Failed to create entity', { error: result.error });
      return failure(new ServiceError(result.error.message));
    }
    
    this.logger.info('Entity created successfully', { entityId: result.data.id });
    return success(result.data);
  } catch (error) {
    this.logger.error('Service error while creating entity', { error });
    return failure(new ServiceError('Failed to create entity'));
  }
}
```

### Server Action Pattern
```typescript
export const createEntityAction = withSession(
  async (params: CreateEntityParams): Promise<CreateEntityResponse> => {
    const client = getSupabaseServerActionClient();
    const logger = getLogger();
    const service = new EntityService(client, logger);
    
    try {
      await verifyCsrfToken(params.csrfToken);
      
      logger.info('Creating entity', { entityData: params.data });
      
      const result = await service.createEntity(params.data);
      if (!result.success) {
        return createEntityFailure(result.error.message, ErrorCodes.SERVICE_LEVEL_ERROR);
      }
      
      revalidatePath('/entities');
      return createEntitySuccess();
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      return createEntityFailure(errorMessage, ErrorCodes.INTERNAL_SERVER_ERROR);
    }
  }
);
```

## Error Codes

Use these standard error codes:
- `UNAUTHORIZED`: Authentication required
- `FORBIDDEN`: Insufficient permissions
- `NOT_FOUND`: Resource not found
- `VALIDATION_ERROR`: Invalid input data
- `SERVICE_LEVEL_ERROR`: Business logic error
- `DATABASE_ERROR`: Database operation failed
- `EXTERNAL_SERVICE_ERROR`: Third-party service error
- `INTERNAL_SERVER_ERROR`: Unexpected error

## Best Practices

1. **Single Responsibility**: Each function/class has one clear purpose
2. **Type Safety**: Use TypeScript types throughout
3. **Error Handling**: Always handle errors gracefully
4. **Logging**: Log errors with context
5. **Testing**: Write tests for each layer
6. **Documentation**: Document complex logic
7. **Consistency**: Follow established patterns
8. **Performance**: Consider performance implications
9. **Security**: Validate inputs and handle sensitive data
10. **Maintainability**: Write code for future developers 